# 开发日志

<br>

## fuse介绍
### 简单介绍
下面来介绍FUSE（Filesystem in Userspace），它是一个允许用户空间程序创建和管理文件系统的框架。通过它，开发者能够在不修改内核的情况下，通过用户态程序来实现自定义的文件系统，使得用户可以像操作普通文件一样操作这些文件系统。

<br>

### 组件介绍
FUSE 框架包含3个组件：
1.内核模块fuse.ko：用来接收VFS传递下来的IO请求，并且把这个IO封装之后通过管道发送到用户态；
2.用户态lib库libfuse ：解析内核态转发出来的协议包，拆解成常规的IO请求；
3.mount工具fusermount；
这 3 个组件一起完成一件事：可以在用户态实现文件系统，并且让IO在内核态和用户态文件系统之间自由穿梭。

<br>

## fuse框架的使用
### hello world例子
挂载文件系统并查看
```shell
cd ~/libfuse/build/example
mkdir testmount
ls -al testmount
./hello -f testmount
ls -al testmount
cat testmount/hello
```

卸载文件系统
```shell
fusermount -u testmount
```

<br>

## gtest
### 安装
```shell
cd ~
git clone https://github.com/google/googletest.git
sudo apt-get install cmake
cd ~/googletest/
mkdir build
cd build/
cmake ..
make
sudo make install
```
 
<br>

### 测试文件
在test文件夹下  
由于要用到自己写的c库, 所以测试的代码要写上extern C  
所以先把c库编译成静态库, 再链接到测试的cpp  
 
<br>

### 编写测试
可以在原本的GanshinTest.cpp添加测试代码  
如果需要添加别的测试文件, 则需要重新写cmakelist.txt

<br>


### 运行所有测试案例
```shell
cd build/
./GanshinTest 
```
 
<br>

### 单独运行某个测试样例
```shell
cd build/
./GanshinTest --gtest_filter=GFS_init.init
```

<br>

## LLDB
### 安装
直接在vscode插件市场安装即可

<br>

### 控制程序的版本debug or release
修改CMakeList.txt中的
```c
option(USE_DEBUG "Build with debug flags" ON)
```
debug版本--ON  
release版本--OFF  

<br>

### 查看程序的版本debug or release
```shell
readelf -S ./GanshinTest 
```
有debug相关信息的就是debug版本

<br>

### launch.json 
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug",
            "program": "${workspaceFolder}/build/GanshinTest",
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
```

<br>

## 文件权限(st_mode)
### 数字表示权限
用数字表示文件权限的八进制表示法，通常用于表示文件或目录的权限。

- 0755: 这个权限表示对于一个文件或目录而言，所有者（Owner）具有读、写、执行权限（7），而组（Group）和其他用户（Others）具有读和执行权限（5）。具体解释是：
  - 第一个数字 0 表示特殊权限位，一般不被使用。
  - 第二个数字 7 表示所有者权限，分别是 4（读取）、2（写入）和 1（执行），因此所有者有 4+2+1=7 的权限。
  - 后面的数字 5 表示组权限和其他用户权限，分别具有 4（读取）和 1（执行），因此组和其他用户都有 4+1=5 的权限。

- 0444: 这个权限表示对于一个文件或目录而言，所有用户（包括所有者、组和其他用户）都具有只读权限。具体解释是：
  - 第一个数字 0 表示特殊权限位。
  - 后面的数字 4 表示所有用户（所有者、组和其他用户）都有读取权限。

在权限设置中，每个数字表示一组权限（针对所有者、组和其他用户），每个权限的数值对应读、写、执行权限的组合。

<br>

### 文件类型
- 普通文件：__S_IFREG，通常表示为 0100000。
- 目录文件：__S_IFDIR，通常表示为 0040000。
- 符号链接文件：__S_IFLNK，通常表示为 0120000。
- 字符设备文件：__S_IFCHR，通常表示为 0020000。
- 块设备文件：__S_IFBLK，通常表示为 0060000。
- 套接字文件：__S_IFSOCK，通常表示为 0140000。
- FIFO（命名管道）文件：__S_IFIFO，通常表示为 0010000。
可以与上面的权限进行或操作

<br>

## 创建过程
### 创建文件系统所在的文件 
```shell
dd bs=1M count=8K if=/dev/zero of=~/GanshinFUSE/out/diskimg
```

<br>

## 格式化程序(GanshinInit)
### 生成一个8M大小的文件作为文件系统的载体；
```shell
dd bs=1M count=8 if=/dev/zero of=~/GanshinFUSE/out/diskimg
```
- dd：这是一个用于复制文件和数据的命令行工具。
- bs=1M：bs 表示块大小（block size），这里设置为 11M。这意味着 dd 命令将每次读取和写入 11M 的数据。
- count=8K：count 表示要复制的块数，这里设置为 8，表示要复制 8 个块，每个块大小为 1MB。
- if=/dev/zero：if 表示输入文件（input file）。在这里，/dev/zero 是一个特殊的设备文件，它会产生连续的零字节数据。
- of=~/GanshinFUSE/out/diskimg：of 表示输出文件（output file）。这里指定的文件路径是 ~/GanshinFUSE/out/diskimg，它将用来存储生成的磁盘镜像。
[dd结果](assets/dd.png)

<br>

### 将文件系统的相关信息写入超级块
这部分根据之前设置的文件系统相关设置进行计算初始化  
从0开始, 数据块的开始块 = 超级块数 + InodeBitMap块数 + DataBitMap块数 + Inode块数  

<br>

### 初始化Bitmap
#### 需要把InodeBitmap的初始化的对应块
1. 根目录

需要把第一个Byte的第一个bit置1  
Inode的bitmap的一个Byte对应一个块  

<br>

#### 需要把DataBitmap的初始化的对应块
1. SuperBlock
2. InodeBitmap
3. DataBitmap
4. 根目录

<br>

#### 初始化过程  
初始化的过程如下（和初始化InodeBitmap同）：  
- 首先，通过一些预定义的常量计算了位图应占用的字节数。然后按字节将部分初始化为全1，表示这些块已被占用。  
- 接着，在最后一个字节中，使用循环设置了部分位为1，表示剩余的一些块也被占用。  
- 最后，将位图的剩余部分清零，确保文件系统中未分配的块被标记为未使用状态。   



<br>

### 初始化Inode
#### 将根目录的相关信息填写到inode区的第一个inode。
**索引表结构**
i节点, 根目录指向data区的一个块地址

<br>

## 文件系统实现(GanshinFS)
### 初始化GFS_init
暂时没有什么要初始化操作的

<br>

### 获取文件属性GFS_getattr
要利用到Config.h定义的GInode数据结构   
先根据路径获取对应文件的inode，然后再将inode赋值给stbuf  
路径解析:  
- 根据给定路径，逐级解析路径中的目录或文件名，并从文件系统中查找相应的文件或目录信息。
- 通过循环逐级遍历路径的各个部分，根据路径中的每一级目录名，在文件系统中寻找相应的目录项（GFileDir结构体），以获取相应的属性信息。
- 若路径指向最终的文件或目录，将其属性信息复制到传入的attr参数中，并进行一些额外的判断，例如检查文件名和文件类型等是否匹配。
- 在GFileDir结构体中就存储有该指向文件的对应的inode id，然后通过inode id计算对应的块号和偏移，再通过块号和偏移获取到对应的Inode数据；最后再将inode信息赋值给stbuf。


<br>

### createFileByPath函数
- 变量初始化和内存分配：
初始化了一些变量和指针，并为文件名、扩展名、全名以及剩余路径分配了内存空间。
- 路径解析和文件名处理：
使用divideFileNameByPath函数从给定的路径中提取文件名、扩展名、全名和剩余路径。这些信息将用于创建新文件或目录。
- 获取父目录的索引节点块：
使用getInodeBlkByPath函数获取指定路径的父目录的索引节点块编号。
- 检查文件或目录是否已存在：
使用getFileDirByPath函数检查要创建的文件或目录是否已经存在。如果存在，输出错误信息并跳转到error标签处。
- 创建新文件或目录：
  - 使用哈希函数计算文件名和扩展名的哈希值。
  - 初始化一个GFileDir结构体，并设置其中的一些属性，如文件名、扩展名、父目录的索引节点编号和文件类型。
  - 调用createFileDirByHash函数，根据哈希值在目录中创建新的文件或目录项。
- 成功和错误处理：
如果创建成功，输出成功信息；如果发生错误，输出相应的错误信息并跳转到error标签处进行内存释放和返回错误代码。
- 释放内存：
在函数末尾释放了之前动态分配的内存空间。

<br>


### createFileDirByHash
- 获取文件权限：
根据文件的类型（文件还是目录），设置文件权限。这里使用了st_mode字段的特定标志（__S_IFDIR代表目录，__S_IFREG代表文件）。
- 根据哈希值创建文件目录项：
根据哈希值的范围，确定文件所处的层级（0级、1级、2级、3级间接块），并执行相应的操作来创建文件目录项。
针对不同层级的间接块，找到合适的地址（可能是直接索引块、一次间接块、二次间接块或三次间接块），并在对应的数据块中创建文件目录项，其中创建操作会在data的bitmap中找到一个空闲的data块。
- 分配inode：
根据inode的bitmap找到一个空闲的inode块，并将其标记为已使用，作为新文件的inode。
初始化这个新inode，设置相关的属性（如文件权限等）。
将新的inode写入文件系统。
- 更新文件目录项：
更新传入的文件目录项结构体中的inode块号，指向新创建的inode。
- 写入数据块：
将创建的文件目录项写入到数据块中。
将数据块写入到文件系统。
- 错误处理：
如果在创建过程中出现错误，会释放之前分配的内存资源，并返回错误码。

<br>

### removeFileByPath
- 变量声明和内存分配：
声明了一系列变量和指针，分配了内存空间，包括文件名、扩展名、全名、剩余路径以及一个GFileDir结构体指针。
- 路径解析和获取信息：
使用divideFileNameByPath函数从给定的路径中提取文件名、扩展名、全名和剩余路径，同时获取文件类型信息。
- 获取父目录的索引节点块：
使用getInodeBlkByPath函数获取指定路径的父目录的索引节点块编号。
- 检查文件是否存在：
使用getFileDirByPath函数检查要删除的文件是否存在。如果不存在，输出相应错误信息并跳转到error标签处。
- 检查文件类型：
检查获取到的文件信息与要删除的文件类型是否一致。如果类型不匹配，输出错误信息并跳转到error标签处。
- 删除文件：
根据文件名的哈希值和父目录的索引节点块编号调用removeFileByHash函数删除文件。
- 成功和错误处理：
如果成功删除文件，输出成功信息；如果出现错误，输出相应错误信息并跳转到error标签处进行内存释放和返回错误代码。
- 释放内存：
在函数末尾释放了之前动态分配的内存空间。

<br>

### removeFileByHash
- 根据哈希值删除文件：
通过判断哈希值的范围，确定文件所处的层级（0级、1级、2级、3级间接块），并进行相应的处理。
对于不同级别的间接块，根据哈希值计算出文件目录的位置，并执行相应的操作来删除文件。
- 回收资源：
根据文件目录结构和哈希值，找到对应的文件目录项，并将其从数据块中移除，释放对应的数据块和索引块。
对应的索引块如果已不再包含任何文件目录项，则在Bitmap中将其标记为未使用。
- 更新目录inode：
每次删除操作后，需要更新文件目录的inode，确保文件系统结构的正确性。

<br>

### getFileDataByInodeId
- 初始化与计算：
根据偏移量和最大数据块大小计算出数据块偏移和数据偏移，用来确定从哪里开始读取文件数据。
- 获取相应的inode信息：
通过给定的inode ID获取对应的inode信息，这包括文件的大小和分配的数据块地址。
- 读取文件数据：
根据文件的存储结构，分为直接索引、一次间接、二次间接和三次间接来读取文件数据。每一层级都需要从相应的数据块中读取数据，并在缓冲区中保存这些数据。
- 按层级读取文件数据：
对于直接索引，直接读取指向数据块的地址并将数据读入缓冲区。
对于一次间接，先获取一级间接索引块，再通过这个间接索引块获取指向的数据块地址，并将数据读入缓冲区。
对于二次间接，先获取二级间接索引块，再通过它获取一级间接索引块，再通过一级间接索引块获取指向的数据块地址，并将数据读入缓冲区。
对于三次间接，先获取三级间接索引块，再通过它获取二级间接索引块，再通过二级间接索引块获取一级间接索引块，最后通过一级间接索引块获取指向的数据块地址，并将数据读入缓冲区。
- 错误处理：
在每个步骤中，如果出现了错误（比如数据块地址为负数或达到文件末尾），会跳转到错误处理部分，释放之前分配的内存资源，并返回错误码。
- 成功提示：
如果成功读取文件数据，会打印成功提示。

<br>

### writeFileDataByInodeId
- 初始化与计算：
根据偏移量和最大数据块大小计算出数据块偏移和数据偏移，确定从文件的哪个位置开始写入数据。
- 获取相应的inode信息：
通过给定的inode ID获取对应的inode信息，包括文件的大小和分配的数据块地址。
- 写入文件数据：
根据文件的存储结构，分为直接索引、一次间接、二次间接和三次间接来写入文件数据。每一层级都需要将数据写入相应的数据块中。
- 按层级写入文件数据：
对于直接索引，直接写入指向数据块的地址对应的数据块中。
对于一次间接，先获取一级间接索引块，再通过这个间接索引块获取指向的数据块地址，并将数据写入其中。
对于二次间接，先获取二级间接索引块，再通过它获取一级间接索引块，再通过一级间接索引块获取指向的数据块地址，并将数据写入其中。
对于三次间接，先获取三级间接索引块，再通过它获取二级间接索引块，再通过二级间接索引块获取一级间接索引块，最后通过一级间接索引块获取指向的数据块地址，并将数据写入其中。
获取索引块的过程中，如果遇到未申请的块，会根据databitmap申请空闲块，并将对应块初始化。
- 错误处理：
如果在写入过程中出现了错误（比如偏移量超出文件大小或文件过大），会返回相应的错误码并输出错误信息。
- 更新inode信息：
在写入完成后，会更新对应的inode信息，包括文件大小、权限等，并将这些更新后的信息写回文件系统中。
- 成功提示：
如果成功写入文件数据，会打印成功提示。

<br>

### iterFileDirByInodeId
- 变量初始化：函数一开始分配了用于存储各种数据结构的内存，并初始化一些计数器和辅助变量。
- 获取目标 inode：通过给定的 inode ID，使用 getInodeByInodeId 函数获取对应的 GInode 结构体信息。
- 遍历文件目录：
函数从直接地址开始遍历文件目录项，检查文件目录中的每个条目并将文件名/目录名添加到提供的缓冲区 buf 中，使用了 filler 函数。
针对直接地址、一次间接、二次间接和三次间接块，分别读取文件目录项，确保将所有文件/目录名添加到缓冲区中。
- 文件名构建与填充：
在每个文件目录项中，通过检查文件名和文件扩展名的有效性，构建完整的文件/目录名，并使用 filler 函数将它们添加到提供的缓冲区中。
- 错误处理：
如果在读取过程中出现错误（比如获取 inode 失败、地址为负等情况），函数将返回相应的错误码，并释放分配的内存。
- 资源释放：
函数结束时释放了所分配的 GInode、GFileDir 和数据块结构体的内存。

<br>

## 常见问题  
Q: 为什么我设了断点没用  
A: 因为编译出来的不是debug版本, 更改cmakelist.txt  
---  
Q: str的memcpy, 字符串不对?  
A: 注意len()要加一, 把'\0'也复制   
---   
Q: 挂载后出现"由软件导致的连接断开"  
A: 试着不要在sudo环境下运行
---  
Q: 出现" 输入/输出错误"  
A: inode中的st_mode不对  

<br>


## 参考资料
- [inode 详解](https://www.cnblogs.com/llife/p/11470668.html)
- [fuse结合buildroot](https://cloud.tencent.com/developer/article/1006138?areaSource=106002.3)

<br>

## 进度
## 开发计划(ToDos)
- [x] 了解fuse怎么使用  
- [x] 运行hello world例子
- [x] 尝试读懂hello.c的源码
- [x] 写CMakeList.txt
- [x] 根据hello.c的源码, 试着写一下GanshinFUSE的类似代码
- [x] 实现格式化程序(GanshinInit)
- [x] 文件系统实现(GanshinFS)
- [x] GFS_init初始化
- [x] GFS_getattr获取文件属性
- [x] GFS_mknod创建文件
- [x] 该addr的时候把目录的addr也给改了, 出问题  
- [x] 一个inode就占了一个块了,太过于浪费, 重构代码  
- [x] bitmap初始化问题  
- [x] 写一个判断该块是否free的函数  
- [x] 根目录的st_size不太对  
- [x] removeFileByPath把超级块给弄成0了
- [x] 写入文件或者读取不全  
- [x] writeFileDataByInodeId按照size来遍历, 但是之前已经初始化为零了, 不会写不进去吗?  
- [ ] 优化disk的地址逻辑, 弄成不用手动设置
- [ ] 将所有的步骤写成脚本
- [ ] 解决哈希冲突
- [ ] 支持文件和文件夹同名
- [ ] 优化函数参数名

<br>
